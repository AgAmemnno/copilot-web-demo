<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVGグリッドレイアウトのWeb Component (外部テンプレートフェッチ)</title>
    <style>
        /* グローバルスタイル */
        body {
            margin: 0;
            background-color: #f0f0f0;
            padding: 20px;
        }
        /* triangle-grid コンポーネントの配置スタイル */
        triangle-grid {
            display: block;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            min-height: 100px; /* テンプレート読み込み中の仮の高さ */
            border: 1px dashed #ccc; /* 読み込み中の境界線（任意） */
        }
        triangle-grid:not(:defined) { /* 未定義状態のスタイル（任意） */
            display: block;
            text-align: center;
            padding: 20px;
            color: #aaa;
            content: "Loading Grid...";
        }
    </style>



    </head>
<body>

<triangle-grid count="12" template-id="triangle-grid-template" template-src="triangle-grid-template.html"></triangle-grid>
<row-flex rows="5" min-item-width="80" gap="8"></row-flex>

<script>
//==================================================
// 0. TemplateFetcher クラス (Head -> Storage -> Fetch)
//==================================================
class TemplateFetcher {
    static #pendingFetches = new Map();

    /**
     * 指定されたIDのテンプレートを Head, sessionStorage, または Fetch で取得し、キャッシュする
     * @param {string} templateId - 取得/復元するテンプレート要素のID
     * @param {string | null} [templateUrl=null] - Fetch する場合のURL (任意)
     * @returns {Promise<string | null>} テンプレートのHTML文字列、または失敗した場合は null
     */
    static async getTemplateHtml(templateId, templateUrl = null) {
        const idCacheKey = `template-id-${templateId}`;    // ID保存用キー
        const htmlCacheKey = `template-html-${templateId}`; // HTML保存用キー

        // 1. Head 内を検索
        let templateElement = document.getElementById(templateId);
        if (templateElement && templateElement.tagName === 'TEMPLATE') {
            console.log(`Template found in <head>: ${templateId}`);
            return templateElement;
        }

        // 2. Head にない場合、sessionStorage を確認
        console.log(`Template not found in <head>, checking sessionStorage for: ${templateId}`);
        try {
            const cachedId = sessionStorage.getItem(idCacheKey);
            if (cachedId === templateId) {
                console.log(`Template found in sessionStorage for: ${templateId}. Restoring to <head>.`);
                // <head> 内にテンプレート要素を復元
                templateElement = document.createElement('template');
                templateElement.id = templateId;
                templateElement.innerHTML = sessionStorage.getItem(htmlCacheKey);
                document.head.appendChild(templateElement);
                console.log(`Template restored to <head> for: ${templateId}`);
                return templateElement;
            } else {
                 console.log(`Template not found in sessionStorage for: ${templateId}`);
            }
        } catch (e) { console.warn('Failed to access sessionStorage:', e); }

        // 3. Head にも sessionStorage にもない場合、Fetch を試みる
        if (!templateUrl) {
             console.error(`Template "${templateId}" not found in <head> or sessionStorage, and no template-src provided.`);
             return null;
        }

        if (TemplateFetcher.#pendingFetches.has(templateUrl)) {
            console.log(`Fetch already pending for: ${templateUrl}. Waiting for existing fetch to complete.`);
            // 進行中の fetch Promise が解決されるのを待つ
            return TemplateFetcher.#pendingFetches.get(templateUrl);
        }
        // 新しい fetch を開始し、その Promise を pendingFetches に登録
        const fetchPromise = (async () => {
            console.log(`Fetching template from server: ${templateUrl}`);
            try {
                const response = await fetch(templateUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status} for ${templateUrl}`);
                }
                const htmlString = await response.text();
                console.log(`Template fetched successfully from: ${templateUrl}`);

                // <head> 内にテンプレート要素を作成・追加
                templateElement = document.createElement('template');
                templateElement.id = templateId;
                templateElement.innerHTML = htmlString;
                document.head.appendChild(templateElement);
                console.log(`Template added to <head> after fetch for: ${templateId}`);

                // sessionStorage にキャッシュ
                try {
                    sessionStorage.setItem(idCacheKey, templateId);
                    sessionStorage.setItem(htmlCacheKey, htmlString);
                    console.log(`Template cached in sessionStorage after fetch for: ${templateId}`);
                } catch (e) { console.warn(`Failed to cache template in sessionStorage for ${templateId}:`, e); }

                return templateElement; // 成功したらHTML文字列を返す
            } catch (error) {
                console.error(`Failed to fetch template from ${templateUrl}:`, error);
                return null; // 失敗したら null を返す
            } finally {
                // 成功・失敗に関わらず、完了したら pendingFetches から削除
                TemplateFetcher.#pendingFetches.delete(templateUrl);
                console.log(`Fetch completed (success/failure) for: ${templateUrl}`);
            }
        })(); // 即時実行関数で Promise を作成

        TemplateFetcher.#pendingFetches.set(templateUrl, fetchPromise); // Promise を Map に保存
        return fetchPromise; // この Promise を返す
    }
}


//==================================================
// 1. SvgAnimator クラス (展開されたコード)
//==================================================
class SvgAnimator {
    constructor(element, keyframes, options) {
        this.element = element;
        this.keyframes = keyframes;
        this.options = options;
        this.animation = null;
    }

    play() {
        if (!this.element) return;

        if (this.animation && this.animation.playState === 'paused') {
            this.animation.play();
        } else if (!this.animation || this.animation.playState === 'finished' || this.animation.playState === 'idle') {
            try {
                this.animation = this.element.animate(this.keyframes, this.options);
                console.log(`Animation started/restarted`, this.keyframes, this.options);
            } catch (e) {
                console.error("Animation failed:", e);
                console.error("Keyframes:", this.keyframes);
                console.error("Options:", this.options);
            }
        }
    }

    pause() {
        if (this.animation && this.animation.playState === 'running') {
            this.animation.pause();
            console.log('Animation paused');
        }
    }

    togglePlay() {
        if (!this.animation || this.animation.playState === 'finished' || this.animation.playState === 'idle') {
            this.play();
        } else if (this.animation.playState === 'paused') {
            this.play();
        } else if (this.animation.playState === 'running') {
            this.pause();
        }
    }
}
class SvgInstaller {
    /**
     * SVG要素に初期トランスフォームを設定する
     * @param {SVGElement} element - 対象のSVG要素
     * @param {string} transformValue - 設定する transform 属性の値
     */
    constructor(element, transformValue) {
        this.element = element;
        this.transformValue = transformValue;
    }

    /**
     * 初期トランスフォームを適用する
     */
    install(root) {
        if (this.element && typeof this.transformValue === 'string') {
        // SVGTransformList を取得
        const tfmList = this.element.transform.baseVal;

        // 既存の transform をクリア (初期状態を設定するため)
        tfmList.clear();

        // 重心座標を計算
        const rawCentroidY = (0 + 86.6 + 86.6) / 3;
        const centroidY = parseFloat(rawCentroidY.toFixed(3));
        const centroidX = 50;

        // 1. 重心を原点(0,0)に移動する Transform
        const translateToOrigin = root.createSVGTransform();
        translateToOrigin.setTranslate(-centroidX, -centroidY);

        // 2. 原点周りで180度回転する Transform
        const rotate = root.createSVGTransform();
        rotate.setRotate(180, 0, 0); // angle, cx, cy

        // 3. 元の位置（重心）に戻す Transform
        const translateBack = root.createSVGTransform();
        translateBack.setTranslate(centroidX, centroidY);

        // SVGTransformList に追加 (適用順は逆になることに注意: translateBack -> rotate -> translateToOrigin)
        tfmList.appendItem(translateBack);
        tfmList.appendItem(rotate);
        tfmList.appendItem(translateToOrigin);
            console.log(`Initial transform installed on element:`, this.transformValue);
        } else {
            console.error('SvgInstaller: Invalid element or transformValue provided.');
        }
    }
}

//==================================================
// 2. TriangleIcon Web Component (変更なし)
//==================================================
class TriangleIcon extends HTMLElement {
    #templateId = '';
    #templateSrc = ''; // template-src も保持
    #shadowRoot; 
    #animator = null;
    #maskUseElement = null; // マスク要素への参照を保持
    #installer = null; // SvgInstaller のインスタンスを保持
    #svgRoot = null; // SVG要素への参照を保持
    constructor() { 
        super(); 
        this.#shadowRoot = this.attachShadow({ mode: 'open' });
    }

    async ishadow(){
        const template = await TemplateFetcher.getTemplateHtml("triangle-icon-template", "triangle-icon-template.html");
        if (!template) { console.error('TriangleIcon: Template content not found.'); return; }
        this.#shadowRoot.appendChild(template.content.cloneNode(true));
        this.#svgRoot = this.#shadowRoot.getElementById('svgRoot'); 
        this.#updateViewBox();
        this.#maskUseElement = this.#shadowRoot.getElementById('maskUseElement');
        this.#install();
    }
    #updateViewBox() { 
        if (this.#svgRoot) { 
            const viewBoxValue = this.getAttribute('view-box') || '0 0 100 86.6'; 
            this.#svgRoot.setAttribute('viewBox', viewBoxValue); 
        } 
    }
    // 初期トランスフォームを設定するメソッド
    #install() {
        if (this.#maskUseElement && !this.#installer) {
            const rawCentroidY = (0 + 86.6 + 86.6) / 3;
            const centroidY = parseFloat(rawCentroidY.toFixed(3));
            const baseTranslate = `translate(50px, ${centroidY}px)`;
            const baseRotateOrigin = `translate(-50px, -${centroidY}px)`;
            const initialTransform = `${baseTranslate} rotate(180deg) ${baseRotateOrigin}`; // 初期状態 (180度回転)

            this.#installer = new SvgInstaller(this.#maskUseElement, initialTransform);
            this.#installer.install(this.#svgRoot);
        } else if (!this.#maskUseElement) {
             // 要素が見つからない場合、少し待って再試行
             requestAnimationFrame(() => this.#install());
        }
    }

    #initAnimation() { 
        const maskUseElement = this.#shadowRoot.getElementById('maskUseElement'); 
        if (maskUseElement && !this.#animator) { 
            const rawCentroidY = (0 + 86.6 + 86.6) / 3; 
            const centroidY = parseFloat(rawCentroidY.toFixed(3)); 
            const baseTranslate = `translate(50px, ${centroidY}px)`; 
            const baseRotateOrigin = `translate(-50px, -${centroidY}px)`; 
            const keyframes = [ { transform: `${baseTranslate} rotate(180deg) ${baseRotateOrigin}` }, { transform: `${baseTranslate} rotate(540deg) ${baseRotateOrigin}` } ]; 
            const options = { duration: 3000, iterations: Infinity, easing: 'linear' }; 
            this.#animator = new SvgAnimator(maskUseElement, keyframes, options); 
            this.#animator.play(); 
            this.addEventListener('click', () => { 
                if (this.#animator) { 
                    this.#animator.togglePlay(); } });
                } 
                else if (!maskUseElement) { 
                    requestAnimationFrame(() => this.#initAnimation()); 
                } 
            }

    static get observedAttributes() { return ['view-box']; }
    attributeChangedCallback(name, oldValue, newValue) { 
        if (name === 'view-box' && oldValue !== newValue) 
        { 
            this.#updateViewBox(); 
        } 
    }
    connectedCallback() 
    { 
        this.ishadow();
        if (!this.#shadowRoot.getElementById('svgRoot')?.getAttribute('viewBox') && this.hasAttribute('view-box')) 
        { 
            this.#updateViewBox(); 
        } 
        this.#initAnimation(); 
    }
}
customElements.define('triangle-icon', TriangleIcon);

class TriangleGrid extends HTMLElement {
    #shadowRoot;
    #gridContainer = null;
    #templateId = '';
    #templateSrc = ''; // template-src も保持

    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'open' });
        this.#shadowRoot.innerHTML = `<style>:host{display:block;text-align:center;padding:20px;color:#aaa;border:1px dashed #ccc;min-height:50px;}</style><p id ="msgbox">Initializing grid...</p>`;
    }

    // テンプレートを非同期で適用するメソッド
    async #applyTemplate() {
        this.#templateId = this.getAttribute('template-id');
        this.#templateSrc = this.getAttribute('template-src'); // template-src も取得

        if (!this.#templateId) {
            console.error('TriangleGrid: template-id attribute is missing.');
            this.#shadowRoot.querySelector("#msgbox").innerHTML = '<p style="color: red;">Error: template-id attribute is missing.</p>';
            return;
        }

        // TemplateFetcher を使用 (IDとURLを渡す)
        const template = await TemplateFetcher.getTemplateHtml(this.#templateId, this.#templateSrc);

        if (template) {

            this.#shadowRoot.appendChild(template.content.cloneNode(true));

            // グリッドコンテナへの参照を取得
            this.#gridContainer = this.#shadowRoot.querySelector('.container');
            if (!this.#gridContainer) {
                console.error('TriangleGrid: .container element not found in template.');
                this.#shadowRoot.innerHTML = '<p style="color: red;">Error: .container not found in template.</p>';
                return;
            }
            console.log(`TriangleGrid: Template "${this.#templateId}" applied successfully.`);
            this.#shadowRoot.querySelector("#msgbox").style.display = "none";
            // テンプレート適用後にアイコンを追加
            this.#addIconsBasedOnAttribute();

        } else {
            // テンプレート取得失敗時のエラー表示
            this.#shadowRoot.innerHTML = `<p style="color: red;">Error applying template "${this.#templateId}".</p>`;
            console.error(`TriangleGrid: Failed to apply template content for id "${this.#templateId}".`);
        }
    }

    // アイコンを追加するメソッド (変更なし)
    #addIcons(count) {
        if (!this.#gridContainer) {
            console.warn('#addIcons called but grid container is not available.');
            return;
        }
        this.#gridContainer.innerHTML = '';
        for (let i = 0; i < count; i++) {
            const icon = document.createElement('triangle-icon');
            icon.setAttribute('view-box', '0 0 100 86.6');
            this.#gridContainer.appendChild(icon);
        }
        console.log(`Added ${count} icons.`);
    }

    // count 属性に基づいてアイコンを追加するヘルパー (変更なし)
    #addIconsBasedOnAttribute() {
        const count = parseInt(this.getAttribute('count') || '12', 10);
        this.#addIcons(count);
    }

    // 監視する属性 (template-src を追加)
    static get observedAttributes() {
        return ['count', 'template-id', 'template-src'];
    }

    // 属性変更時のコールバック
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue) return;

        if (name === 'count') {
            // コンテナが準備できていればアイコン数を更新
            if (this.#gridContainer) {
                const count = parseInt(newValue, 10) || 0;
                this.#addIcons(count);
            }
        } else if (name === 'template-id')
        {
            let templateId = this.getAttribute('template-id');
            if( this.#templateId  == templateId ){
                // template-id または template-src が変更された場合、再度テンプレートを適用
                this.#gridContainer = null; // コンテナ参照をリセット
                this.#applyTemplate(); // 新しいID/SRCでテンプレートを適用
            }
        }else if(name === 'template-src') {
            let templateSrc = this.getAttribute('template-src');
            if( this.#templateSrc  == templateSrc ){
                // template-id または template-src が変更された場合、再度テンプレートを適用
                this.#gridContainer = null; // コンテナ参照をリセット
                this.#applyTemplate(); // 新しいID/SRCでテンプレートを適用
            }
        }
    }

    // DOM接続時のコールバック
    connectedCallback() {
        // テンプレートを非同期で適用
        this.#applyTemplate();
    }
}
customElements.define('triangle-grid', TriangleGrid);



//==================================================
// 3. RowOffsetGrid Web Component (新規作成/修正)
//==================================================
class RowFlex extends HTMLElement {
    #shadowRoot;
    #gridContainer = null; // 行を追加するコンテナ
    #resizeObserver = null;
    #currentWidth = 0; // 現在のコンポーネント幅
    #templateId = 'triangle-rowflex-template';
    #templateSrc = 'triangle-rowflex-template.html'; // template-src も保持
    // デフォルト設定
    #config = {
        rows: 4,
        minItemWidth: 100,
        gap: 10
    };

    constructor() {
        super();
        this.#shadowRoot = this.attachShadow({ mode: 'open' });
        this.#updateConfig();
        this.#applyTemplate();
        /*
        this.#shadowRoot.innerHTML = `<style>
            :host { display: block; } 
            .grid-container {
               
                width: 100%;
            }
            .grid-row {
                display: flex; 
                flex-wrap: nowrap; 
                margin-bottom: var(--row-gap, 10px); 
               
            }
            .grid-row > * { 
                flex-shrink: 0; 
                flex-grow: 0;
                width: var(--item-width, 100px); 
                margin-right: var(--col-gap, 10px); 
            }
            .grid-row > *:last-child {
                 margin-right: 0; 
            }
            .grid-row.even-row {
              
                 margin-left: calc( (var(--item-width, 100px) / 2) + (var(--col-gap, 10px) / 2) );
               
            }
        </style>
         <div class="grid-container"></div>`;
        */
       
    }
    async #applyTemplate() {
        //this.#templateId = this.getAttribute('template-id');
        //this.#templateSrc = this.getAttribute('template-src'); // template-src も取得

        const template = await TemplateFetcher.getTemplateHtml(this.#templateId, this.#templateSrc);
        if (!template) { console.error('TriangleIcon: Template content not found.'); return; }
        this.#shadowRoot.appendChild(template.content.cloneNode(true));
        this.#gridContainer = this.#shadowRoot.querySelector('.grid-container');

   
    }
    // 設定を更新するメソッド
    #updateConfig() {
        this.#config.rows = parseInt(this.getAttribute('rows') || this.#config.rows, 10);
        this.#config.minItemWidth = parseInt(this.getAttribute('min-item-width') || this.#config.minItemWidth, 10);
        this.#config.gap = parseInt(this.getAttribute('gap') || this.#config.gap, 10);

        // CSS変数にも反映
        this.style.setProperty('--row-gap', `${this.#config.gap}px`);
        this.style.setProperty('--col-gap', `${this.#config.gap}px`);
        // --item-width は描画時に計算して設定
    }

    // グリッドを再描画するメソッド
    #renderGrid() {
        if (!this.#gridContainer) return;

        const componentWidth = this.offsetWidth; // コンポーネントの現在の幅を取得
        if (componentWidth === 0) {
             console.warn("RowOffsetGrid: Component width is 0, cannot render grid.");
             requestAnimationFrame(() => this.#renderGrid()); // 少し待って再試行
             return;
        }
        this.#currentWidth = componentWidth;

        // 1行に収まるアイテム数を計算
        const itemsPerRow = Math.max(1, Math.floor(
            (componentWidth + this.#config.gap) / (this.#config.minItemWidth + this.#config.gap)
        ));
        // アイテムの実際の幅を計算 (均等割り)
        const actualItemWidth = (componentWidth - (itemsPerRow - 1) * this.#config.gap) / itemsPerRow;

        console.log(`Rendering grid: Width=${componentWidth}, Rows=${this.#config.rows}, ItemsPerRow=${itemsPerRow}, ActualItemWidth=${actualItemWidth.toFixed(1)}`);

        // CSS変数で実際のアイテム幅を設定
        this.style.setProperty('--item-width', `${actualItemWidth}px`);

        // グリッドコンテナをクリア
        this.#gridContainer.innerHTML = '';

        // 行とアイコンを生成
        for (let r = 0; r < this.#config.rows; r++) {
            const rowDiv = document.createElement('div');
            rowDiv.classList.add('grid-row');
            if (r % 2 !== 0) { // 0始まりなので奇数インデックスが偶数行目
                rowDiv.classList.add('even-row');
            }

            for (let i = 0; i < itemsPerRow; i++) {
                const icon = document.createElement('triangle-icon');
                icon.setAttribute('view-box', '0 0 100 86.6');
                rowDiv.appendChild(icon);
            }
            this.#gridContainer.appendChild(rowDiv);
        }
    }

    // ResizeObserver を設定するメソッド
    #observeResize() {
        this.#resizeObserver = new ResizeObserver(entries => {
            // 幅が変わった場合のみ再描画 (無限ループ防止)
            const newWidth = this.offsetWidth;
            if (newWidth > 0 && newWidth !== this.#currentWidth) {
                 console.log("RowOffsetGrid resized, rerendering...");
                 this.#renderGrid();
            }
        });
        // コンポーネント自身のサイズ変更を監視
        this.#resizeObserver.observe(this);
        console.log("ResizeObserver attached to RowOffsetGrid.");
    }

    // 監視する属性
    static get observedAttributes() {
        return ['rows', 'min-item-width', 'gap'];
    }

    // 属性変更時のコールバック
    attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue !== newValue) {
            console.log(`Attribute changed: ${name} from ${oldValue} to ${newValue}`);
            this.#updateConfig(); // 設定を更新
            // 設定変更時にも再描画
            // connectedCallback 前に呼ばれる可能性があるので、描画は connected 後に行う
            if (this.isConnected) {
                 this.#renderGrid();
            }
        }
    }

    connectedCallback() {
        console.log("RowOffsetGrid connected.");
        this.#updateConfig(); // 初期設定を読み込み
        this.#renderGrid();   // 初回描画
        this.#observeResize(); // リサイズ監視を開始
    }

    disconnectedCallback() {
        // コンポーネントがDOMから削除されるときに ResizeObserver を停止
        if (this.#resizeObserver) {
            this.#resizeObserver.disconnect(); // observe(this) だったので disconnect
            this.#resizeObserver = null;
            console.log("ResizeObserver detached from RowOffsetGrid.");
        }
    }
}
customElements.define('row-flex', RowFlex);

</script>

</body>
</html>
