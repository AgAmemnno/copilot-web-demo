<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ランダムグリッド生成 (サブグリッド再構築)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* 元のグリッドセル */
        .grid-cell {
            border: 1px solid #e2e8f0; /* gray-200 */
            transition: background-color 0.3s ease, width 0.3s ease, height 0.3s ease;
            box-sizing: border-box;
            position: relative; /* グループID表示用 */
        }
        /* グループID表示用 (デバッグ用、任意) */
        .grid-cell::after {
            content: attr(data-group-id);
            position: absolute;
            top: 1px;
            left: 1px;
            font-size: 8px;
            color: rgba(0,0,0,0.4);
            font-family: monospace;
        }

        /* グリッドコンテナ共通スタイル */
        .grid-base {
            display: grid;
            border: 1px solid #d1d5db; /* gray-300 */
            background-color: #f9fafb; /* gray-50 */
            padding: 2px;
            margin-bottom: 1rem;
            transition: gap 0.3s ease, row-gap 0.3s ease, column-gap 0.3s ease, justify-content 0.3s ease, align-content 0.3s ease;
        }
        /* 再構築されたグリッドの要素 */
        .rebuilt-element { /* 単一セルとサブグリッドコンテナの共通 */
             border: 1px dashed #a0aec0; /* gray-500 破線 */
             box-sizing: border-box;
             overflow: hidden; /* サブグリッド内容のはみ出し防止 */
        }
        .rebuilt-cell { /* 単一の色付きセル */
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            color: rgba(0,0,0,0.5);
            min-width: 10px;
            min-height: 10px;
        }
         /* サブグリッドコンテナ */
        .subgrid-container {
            display: grid; /* ネストされたグリッド */
            gap: 1px; /* サブグリッド内のギャップ */
            padding: 1px; /* サブグリッド内のパディング */
            background-color: rgba(0,0,0,0.05); /* サブグリッド背景を少し暗く */
        }
        /* サブグリッド内のセル */
        .subgrid-cell {
            background-color: #cbd5e1; /* gray-300相当 */
            border: 1px solid #e2e8f0; /* gray-200 */
            box-sizing: border-box;
            min-width: 4px; /* 最小サイズ */
            min-height: 4px;
        }

        /* 再構築コンテナに最小サイズを設定 */
        #rebuilt-grid-container {
             min-width: 400px;
             min-height: 300px;
        }
        /* コントロール部分 */
        .controls label { white-space: nowrap; }
        .controls input[type=number] { width: 6rem; }
        .controls button { margin-top: 10px; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col justify-center items-center min-h-screen font-sans p-4">

    {/* コントロールセクション (変更なし) */}
    <div class="controls bg-white p-6 rounded-lg shadow-md mb-8 w-full max-w-4xl">
        <h2 class="text-xl font-semibold mb-4 text-center text-gray-700">グリッド設定 & 操作</h2>
        <div class="flex flex-wrap justify-center items-end gap-x-4 gap-y-2">
            {/* 設定項目 */}
            <div><label for="rows">行数:</label><input type="number" id="rows" value="10" min="1"></div>
            <div><label for="cols">列数:</label><input type="number" id="cols" value="10" min="1"></div>
            <div><label for="cellWidth">デフォルト幅(px):</label><input type="number" id="cellWidth" value="30" min="5" step="1"></div>
            <div><label for="cellHeight">高さ(px):</label><input type="number" id="cellHeight" value="30" min="5" step="1"></div>
            <div><label for="targetColWidth">変更後の列幅(px):</label><input type="number" id="targetColWidth" value="60" min="5" step="1"></div>
            <div><label for="maxMargin">最大マージン(px):</label><input type="number" id="maxMargin" value="10" min="0" step="1"></div>
            {/* ボタン群 */}
            <div class="w-full flex flex-wrap justify-center gap-4 mt-4">
                <button id="generateBtn" class="px-5 py-2 bg-blue-500 text-white font-semibold rounded-md hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">生成</button>
                <button id="randomizeBtn" class="px-5 py-2 bg-green-500 text-white font-semibold rounded-md hover:bg-green-600 focus:outline-none focus:ring-2 focus:ring-green-500 focus:ring-offset-2">グループ化</button>
                <button id="randomizeColWidthBtn" class="px-5 py-2 bg-indigo-500 text-white font-semibold rounded-md hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2">列幅ランダム変更</button>
                <button id="rebuildGridBtn" class="px-5 py-2 bg-purple-500 text-white font-semibold rounded-md hover:bg-purple-600 focus:outline-none focus:ring-2 focus:ring-purple-500 focus:ring-offset-2">グリッド再構築</button>
                <button id="randomizeMarginBtn" class="px-5 py-2 bg-pink-500 text-white font-semibold rounded-md hover:bg-pink-600 focus:outline-none focus:ring-2 focus:ring-pink-500 focus:ring-offset-2">マージンランダム変更</button>
                <button id="randomizeContentAlignmentBtn" class="px-5 py-2 bg-teal-500 text-white font-semibold rounded-md hover:bg-teal-600 focus:outline-none focus:ring-2 focus:ring-teal-500 focus:ring-offset-2">配置/間隔ランダム</button>
            </div>
        </div>
    </div>

    {/* 再構築されたグリッド表示コンテナ */}
    <div class="text-center mb-2 font-medium text-gray-600">再構築されたグリッド (サブグリッド含む)</div>
    <div id="rebuilt-grid-container" class="grid-base rounded-lg shadow-md overflow-auto" style="gap: 2px; justify-content: start; align-content: start;">
        {/* 再構築されたグリッド要素 */}
    </div>

    {/* 元のグリッド表示コンテナ */}
    <div class="text-center mb-2 font-medium text-gray-600">元のグリッド (ここでグループ化)</div>
    <div id="grid-container" class="grid-base rounded-lg shadow-md overflow-auto" style="gap: 0px;">
        {/* グリッドセル */}
    </div>

    <script>
        // DOM要素の取得
        const gridContainer = document.getElementById('grid-container');
        const rebuiltGridContainer = document.getElementById('rebuilt-grid-container');
        // ... (他の要素取得は変更なし)
        const rowsInput = document.getElementById('rows');
        const colsInput = document.getElementById('cols');
        const cellWidthInput = document.getElementById('cellWidth');
        const cellHeightInput = document.getElementById('cellHeight');
        const targetColWidthInput = document.getElementById('targetColWidth');
        const maxMarginInput = document.getElementById('maxMargin');
        const generateBtn = document.getElementById('generateBtn');
        const randomizeBtn = document.getElementById('randomizeBtn');
        const randomizeColWidthBtn = document.getElementById('randomizeColWidthBtn');
        const rebuildGridBtn = document.getElementById('rebuildGridBtn');
        const randomizeMarginBtn = document.getElementById('randomizeMarginBtn');
        const randomizeContentAlignmentBtn = document.getElementById('randomizeContentAlignmentBtn');

        // グリッドの状態変数
        let currentRows = 0;
        let currentCols = 0;
        let currentCellWidth = 30;
        let currentCellHeight = 30;
        let currentColumnWidths = [];
        const defaultCellColor = '#ffffff';
        const defaultGap = 0;
        const defaultRebuiltGap = 2;
        const defaultJustifyContent = 'start';
        const defaultAlignContent = 'start';
        let groupCounter = 0; // グループID用カウンター
        let groupData = {}; // グループ情報を保持 { groupId: { color, cells: Set<string> } }

        // ランダムカラー生成
        function getRandomColor() { /* ... (変更なし) ... */
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color.toUpperCase() > '#DDDDDD' ? getRandomColor() : color;
        }

        // セル要素取得ヘルパー
        function getCellElement(container, row, col) { /* ... (変更なし) ... */
            if (container === gridContainer) {
                 return container.querySelector(`.grid-cell[data-row="${row}"][data-col="${col}"]`);
            }
            return null;
        }

        // 均等なグリッドを生成 (またはリセット)
        function generateGrid() {
            gridContainer.innerHTML = '';
            rebuiltGridContainer.innerHTML = '';
            groupCounter = 0; // グループカウンターリセット
            groupData = {}; // グループデータリセット
            // ... (残りの処理は変更なし)
            const rows = parseInt(rowsInput.value, 10) || 10;
            const cols = parseInt(colsInput.value, 10) || 10;
            const cellWidth = parseInt(cellWidthInput.value, 10) || 30;
            const cellHeight = parseInt(cellHeightInput.value, 10) || 30;
            rowsInput.value = Math.max(1, rows);
            colsInput.value = Math.max(1, cols);
            cellWidthInput.value = Math.max(5, cellWidth);
            cellHeightInput.value = Math.max(5, cellHeight);
            currentRows = Math.max(1, rows);
            currentCols = Math.max(1, cols);
            currentCellWidth = Math.max(5, cellWidth);
            currentCellHeight = Math.max(5, cellHeight);
            currentColumnWidths = Array(currentCols).fill(currentCellWidth);
            gridContainer.style.gridTemplateColumns = currentColumnWidths.map(w => `${w}px`).join(' ');
            gridContainer.style.gap = `${defaultGap}px`;
            rebuiltGridContainer.style.gap = `${defaultRebuiltGap}px`;
            rebuiltGridContainer.style.justifyContent = defaultJustifyContent;
            rebuiltGridContainer.style.alignContent = defaultAlignContent;
            for (let i = 0; i < currentRows; i++) {
                for (let j = 0; j < currentCols; j++) {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell', 'rounded-sm');
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    // data-group-id はここでは設定しない
                    cell.style.backgroundColor = defaultCellColor;
                    cell.style.width = `${currentColumnWidths[j]}px`;
                    cell.style.height = `${currentCellHeight}px`;
                    gridContainer.appendChild(cell);
                }
            }
        }

        // ランダムな長方形でグループ化 (グループ情報も記録)
        function randomizeGrouping() {
            if (currentRows === 0 || currentCols === 0) return;

            // 既存のグループ情報をクリア (色だけリセットしない場合)
            // gridContainer.querySelectorAll('.grid-cell').forEach(cell => {
            //     delete cell.dataset.groupId;
            // });
            // groupData = {};

            const numGroups = Math.max(10, Math.floor(currentRows * currentCols / 8));
            const groupedCells = new Set(); // この関数内での重複チェック用

            for (let k = 0; k < numGroups; k++) {
                let startRow, startCol, startCellKey;
                let attempts = 0;
                const maxAttempts = currentRows * currentCols;
                do {
                    startRow = Math.floor(Math.random() * currentRows);
                    startCol = Math.floor(Math.random() * currentCols);
                    startCellKey = `${startRow}-${startCol}`;
                    attempts++;
                    // 既に他のグループに属しているセルは開始点にしない
                    const existingCell = getCellElement(gridContainer, startRow, startCol);
                    if (existingCell && existingCell.dataset.groupId) {
                         startCellKey = null; // 無効な開始点
                    }
                } while ((groupedCells.has(startCellKey) || startCellKey === null) && attempts < maxAttempts);

                if (groupedCells.has(startCellKey) || startCellKey === null || attempts >= maxAttempts) continue;

                const maxWidth = 3, maxHeight = 3;
                let groupWidth, groupHeight;
                do {
                    groupWidth = Math.floor(Math.random() * maxWidth) + 1;
                    groupHeight = Math.floor(Math.random() * maxHeight) + 1;
                } while (groupWidth === 1 && groupHeight === 1);

                const groupColor = getRandomColor();
                const newGroupId = `g${groupCounter++}`; // 新しいグループID
                let canFormGroup = true;
                const currentGroupCellKeys = new Set();

                for (let i = 0; i < groupHeight; i++) {
                    for (let j = 0; j < groupWidth; j++) {
                        const targetRow = startRow + i;
                        const targetCol = startCol + j;
                        const cellKey = `${targetRow}-${targetCol}`;
                        const cell = getCellElement(gridContainer, targetRow, targetCol);
                        // 範囲外、取得失敗、または既にグループ化されている場合は不可
                        if (!cell || targetRow >= currentRows || targetCol >= currentCols || cell.dataset.groupId) {
                            canFormGroup = false; break;
                        }
                        currentGroupCellKeys.add(cellKey);
                    }
                    if (!canFormGroup) break;
                }

                if (canFormGroup) {
                    groupData[newGroupId] = { color: groupColor, cells: new Set() }; // グループ情報を記録
                    for (let i = 0; i < groupHeight; i++) {
                        for (let j = 0; j < groupWidth; j++) {
                            const targetRow = startRow + i;
                            const targetCol = startCol + j;
                            const cellKey = `${targetRow}-${targetCol}`;
                            const cell = getCellElement(gridContainer, targetRow, targetCol);
                            if (cell) {
                                cell.style.backgroundColor = groupColor;
                                cell.dataset.groupId = newGroupId; // data属性でグループIDを設定
                                groupedCells.add(cellKey); // この関数内での重複チェック用
                                groupData[newGroupId].cells.add(cellKey); // グローバルなグループ情報に追加
                            }
                        }
                    }
                }
            }
            console.log("グループ化を実行しました。 Group Data:", groupData);
        }

        // ランダムに選択した列の幅を変更
        function randomizeColumnWidths() { /* ... (変更なし) ... */
            if (currentCols === 0) return;
            const targetWidth = parseInt(targetColWidthInput.value, 10) || 60;
            targetColWidthInput.value = Math.max(5, targetWidth);
            const finalTargetWidth = Math.max(5, targetWidth);
            const randomColIndex = Math.floor(Math.random() * currentCols);
            // 列幅情報を更新
            currentColumnWidths = currentColumnWidths.map((width, index) => {
                 // 既存の幅がデフォルト幅と異なる場合、それは維持する（複数回変更できるように）
                const currentW = currentColumnWidths[index] || currentCellWidth;
                return index === randomColIndex ? finalTargetWidth : currentW;
            });
            const gridTemplateString = currentColumnWidths.map(w => `${w}px`).join(' ');
            gridContainer.style.gridTemplateColumns = gridTemplateString;
            for (let i = 0; i < currentRows; i++) {
                for (let j = 0; j < currentCols; j++) {
                    const cell = getCellElement(gridContainer, i, j);
                    if (cell) {
                        cell.style.width = `${currentColumnWidths[j]}px`;
                    }
                }
            }
            console.log(`列 ${randomColIndex} の幅を ${finalTargetWidth}px に変更しました。`);
        }

        // グリッド再構築機能 (サブグリッド対応)
        function rebuildGridWithSubgrids() { // 関数名を変更 (rebuildGridFromColors -> rebuildGridWithSubgrids)
            if (currentRows === 0 || currentCols === 0) {
                console.warn("元のグリッドがありません。");
                return;
            }

            rebuiltGridContainer.innerHTML = ''; // クリア
            // 再構築グリッドの基本設定
            rebuiltGridContainer.style.gridTemplateColumns = currentColumnWidths.map(w => `${w}px`).join(' ');
            rebuiltGridContainer.style.gridTemplateRows = `repeat(${currentRows}, ${currentCellHeight}px)`;
            rebuiltGridContainer.style.gap = `${defaultRebuiltGap}px`;
            rebuiltGridContainer.style.justifyContent = defaultJustifyContent;
            rebuiltGridContainer.style.alignContent = defaultAlignContent;

            const processedCells = new Set(); // 処理済みセル (r-c 形式)

            for (let r = 0; r < currentRows; r++) {
                for (let c = 0; c < currentCols; c++) {
                    const cellKey = `${r}-${c}`;
                    if (processedCells.has(cellKey)) continue;

                    const originalCell = getCellElement(gridContainer, r, c);
                    if (!originalCell) continue; // 元セルが見つからない場合

                    const groupId = originalCell.dataset.groupId;

                    // --- ケース1: グループ化されたセル ---
                    if (groupId && groupData[groupId]) {
                        const groupInfo = groupData[groupId];
                        // このグループの範囲 (minR, maxR, minC, maxC) を特定
                        let minR = currentRows, maxR = -1, minC = currentCols, maxC = -1;
                        groupInfo.cells.forEach(key => {
                            const [rr, cc] = key.split('-').map(Number);
                            minR = Math.min(minR, rr);
                            maxR = Math.max(maxR, rr);
                            minC = Math.min(minC, cc);
                            maxC = Math.max(maxC, cc);
                        });
                        const groupHeight = maxR - minR + 1;
                        const groupWidth = maxC - minC + 1;

                        // サブグリッドコンテナを作成
                        const subgridContainer = document.createElement('div');
                        subgridContainer.classList.add('rebuilt-element', 'subgrid-container', 'rounded-sm');
                        subgridContainer.style.backgroundColor = groupInfo.color; // 背景はグループ色
                        // メイングリッド上での位置とスパンを設定
                        subgridContainer.style.gridRowStart = minR + 1;
                        subgridContainer.style.gridRowEnd = minR + groupHeight + 1;
                        subgridContainer.style.gridColumnStart = minC + 1;
                        subgridContainer.style.gridColumnEnd = minC + groupWidth + 1;

                        // サブグリッドの内部グリッドを設定 (元のセルの数に基づく)
                        subgridContainer.style.gridTemplateRows = `repeat(${groupHeight}, 1fr)`; // 高さを均等分割
                        subgridContainer.style.gridTemplateColumns = `repeat(${groupWidth}, 1fr)`; // 幅を均等分割

                        // サブグリッド内にセルを追加 (単純なプレースホルダー)
                        for (let sr = 0; sr < groupHeight; sr++) {
                            for (let sc = 0; sc < groupWidth; sc++) {
                                const subCell = document.createElement('div');
                                subCell.classList.add('subgrid-cell');
                                // 必要なら元のセルの情報を反映させることも可能
                                subgridContainer.appendChild(subCell);
                            }
                        }

                        rebuiltGridContainer.appendChild(subgridContainer);

                        // このグループのセルをすべて処理済みにマーク
                        groupInfo.cells.forEach(key => processedCells.add(key));

                    }
                    // --- ケース2: グループ化されていないセル (単色ブロックを探す) ---
                    else {
                        const startColor = originalCell.style.backgroundColor || defaultCellColor;
                        let blockWidth = 1;
                        let blockHeight = 1;

                        // 幅を計算 (グループ化されていない同じ色のセルを探す)
                        while (c + blockWidth < currentCols) {
                            const nextCell = getCellElement(gridContainer, r, c + blockWidth);
                            if (nextCell && !nextCell.dataset.groupId && (nextCell.style.backgroundColor || defaultCellColor) === startColor && !processedCells.has(`${r}-${c + blockWidth}`)) {
                                blockWidth++;
                            } else {
                                break;
                            }
                        }

                        // 高さを計算 (グループ化されていない同じ色のセルを探す)
                        let potentialHeight = 1;
                        while (r + potentialHeight < currentRows) {
                            let rowMatches = true;
                            for (let w = 0; w < blockWidth; w++) {
                                const belowCellKey = `${r + potentialHeight}-${c + w}`;
                                const belowCell = getCellElement(gridContainer, r + potentialHeight, c + w);
                                if (!belowCell || belowCell.dataset.groupId || (belowCell.style.backgroundColor || defaultCellColor) !== startColor || processedCells.has(belowCellKey)) {
                                    rowMatches = false;
                                    break;
                                }
                            }
                            if (rowMatches) {
                                potentialHeight++;
                            } else {
                                break;
                            }
                        }
                        blockHeight = potentialHeight;

                        // 単一セルを作成
                        const rebuiltCell = document.createElement('div');
                        rebuiltCell.classList.add('rebuilt-element', 'rebuilt-cell', 'rounded-sm');
                        rebuiltCell.style.backgroundColor = startColor;
                        rebuiltCell.style.gridRowStart = r + 1;
                        rebuiltCell.style.gridRowEnd = r + blockHeight + 1;
                        rebuiltCell.style.gridColumnStart = c + 1;
                        rebuiltCell.style.gridColumnEnd = c + blockWidth + 1;
                        // rebuiltCell.textContent = `(${r},${c}) ${blockWidth}x${blockHeight}`; // デバッグ用
                        rebuiltGridContainer.appendChild(rebuiltCell);

                        // このブロックのセルを処理済みにマーク
                        for (let i = 0; i < blockHeight; i++) {
                            for (let j = 0; j < blockWidth; j++) {
                                processedCells.add(`${r + i}-${c + j}`);
                            }
                        }
                    }
                }
            }
            console.log("グリッドを再構築しました (サブグリッド対応)。");
        }


        // 再構築グリッドのマージン（ギャップ）をランダムに変更
        function randomizeRebuiltGridMargins() { /* ... (変更なし) ... */
            if (!rebuiltGridContainer.hasChildNodes()) { console.warn("再構築されたグリッドがありません。"); return; }
            const maxMargin = parseInt(maxMarginInput.value, 10) || 10;
            maxMarginInput.value = Math.max(0, maxMargin);
            const finalMaxMargin = Math.max(0, maxMargin);
            const randomRowGap = Math.floor(Math.random() * (finalMaxMargin + 1));
            const randomColGap = Math.floor(Math.random() * (finalMaxMargin + 1));
            rebuiltGridContainer.style.rowGap = `${randomRowGap}px`;
            rebuiltGridContainer.style.columnGap = `${randomColGap}px`;
            console.log(`再構築グリッドのギャップを 行: ${randomRowGap}px, 列: ${randomColGap}px に変更しました。`);
         }

        // 再構築グリッドのコンテンツ配置/間隔をランダムに変更
        function randomizeRebuiltGridContentAlignment() { /* ... (変更なし) ... */
            if (!rebuiltGridContainer.hasChildNodes()) { console.warn("再構築されたグリッドがありません。"); return; }
            const justifyContentOptions = ['start', 'end', 'center', 'space-between', 'space-around', 'space-evenly'];
            const alignContentOptions = ['start', 'end', 'center', 'space-between', 'space-around', 'space-evenly', 'stretch'];
            const randomJustify = justifyContentOptions[Math.floor(Math.random() * justifyContentOptions.length)];
            const randomAlign = alignContentOptions[Math.floor(Math.random() * alignContentOptions.length)];
            rebuiltGridContainer.style.justifyContent = randomJustify;
            rebuiltGridContainer.style.alignContent = randomAlign;
            console.log(`再構築グリッドの配置を justify-content: ${randomJustify}, align-content: ${randomAlign} に変更しました。`);
        }

        // イベントリスナー設定
        generateBtn.addEventListener('click', generateGrid);
        randomizeBtn.addEventListener('click', randomizeGrouping);
        randomizeColWidthBtn.addEventListener('click', randomizeColumnWidths);
        // rebuildGridBtn のリスナーを新しい関数に変更
        rebuildGridBtn.addEventListener('click', rebuildGridWithSubgrids);
        randomizeMarginBtn.addEventListener('click', randomizeRebuiltGridMargins);
        randomizeContentAlignmentBtn.addEventListener('click', randomizeRebuiltGridContentAlignment);

        // 初期表示
        document.addEventListener('DOMContentLoaded', generateGrid);
    </script>

</body>
</html>
