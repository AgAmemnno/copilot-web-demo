<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PolyHedronLayout</title>
    <script type="importmap">{"imports": {"jquery": "https://cdn.jsdelivr.net/npm/jquery@3.3.1/+esm"}}</script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Aboreto&family=Bungee+Tint&family=Dela+Gothic+One&family=Special+Elite&display=swap" rel="stylesheet">

    <style>
        .grid{
        --grid-color-major: rgba(0, 255, 255, 0.1);  /* Cyan lines */
        --grid-color-minor: rgba(0, 255, 255, 0.05); /* Fainter cyan lines */
        --grid-size-major: 100px;
        --grid-size-minor: 20px;
        background-color: #0a0a10; /* Dark blue/black base */
        background-image:
            /* Minor grid */
            linear-gradient(var(--grid-color-minor) 1px, transparent 1px),
            linear-gradient(90deg, var(--grid-color-minor) 1px, transparent 1px),
            /* Major grid */
            linear-gradient(var(--grid-color-major) 2px, transparent 2px),
            linear-gradient(90deg, var(--grid-color-major) 2px, transparent 2px);
        background-size:
            var(--grid-size-minor) var(--grid-size-minor),
            var(--grid-size-minor) var(--grid-size-minor),
            var(--grid-size-major) var(--grid-size-major),
            var(--grid-size-major) var(--grid-size-major);
        /* Offset minor grid slightly for better look */
        background-position: -1px -1px, -1px -1px, -1px -1px, -1px -1px;
        }

        .elite{
            font-family: "Special Elite", system-ui;
            font-weight: 400;
            font-style: normal;
            font-size:10rem;
            position:fixed;
            z-index:-1;
        }
    </style>
</head>
<body class="grid">
    <p class="elite">asdasdbni 123456k asocjaposd ascnPANSCaknascn </p>
    <script type="module">
        class BaseHTMLComponent extends HTMLElement {
            constructor() {
            super();
            this.attachShadow({ mode: 'open' });
            }

            getId(name){
                return this.shadowRoot.getElementById(name);
            }
            
            query() {
            return this.shadowRoot.querySelector(this._selector);
            }
            connectedCallback(){}
            disconnectedCallback(){}
            adoptedCallback(){}
            attributeChangedCallback(name, oldValue, newValue){}
        }


        class BaseHTMLComponentWithEvent extends BaseHTMLComponent {
        constructor() {
            super();
        }

        generateId() {
            return 'component-' + Math.random().toString(36).substr(2, 9);
        }

        registerId() {
            sessionStorage.setItem(this.id, JSON.stringify({ events: [], dependencies: [] }));
        }

        retrieveEventInfo() {
            const eventInfo = sessionStorage.getItem(this.id);
            return eventInfo ? JSON.parse(eventInfo) : { events: [], dependencies: [] };
        }

        registerEvent(eventName, dependencies = []) {
            const eventInfo = this.retrieveEventInfo();
            eventInfo.events.push(eventName);
            eventInfo.dependencies.push(...dependencies);
            sessionStorage.setItem(this.id, JSON.stringify(eventInfo));
        }

        resolveDependencies() {
            const eventInfo = this.retrieveEventInfo();
            const resolvedEvents = eventInfo.dependencies.every(dep => sessionStorage.getItem(dep));
            if (resolvedEvents) {
            this.registerEvent('resolved');
            }
        }

        dispatchCustomEvent(eventName, detail = {}) {
            const event = new CustomEvent(eventName, { detail });
            document.dispatchEvent(event);
        }
        }

        import $ from 'jquery';
        class VirtualKeyboardComponent extends  BaseHTMLComponentWithEvent {
            _selector = 'virtual-keyboard-component';
            externalCB = (f) =>{};
            constructor() {
                super();
            }
            init(){
                this.id = this.generateId();
                sessionStorage.setItem("test1",this.id);
                this.registerId();
                this.eventInfo = this.retrieveEventInfo();
            }
            ishadow1() {
                this.init();
                this.shadowRoot.innerHTML = `
            <style>
                /* --- Basic Container Styles --- */
                #wrap {
                position: absolute; top: 10vh; left: 10vw; width: 80vw; height: 80vh;
                z-index: 1; display: flex; flex-direction: column; justify-content: center;
                align-items: center; padding: 20px; box-sizing: border-box; gap: 2px;
                pointer-events: none;
                }
                #keyboard, #icon { pointer-events: auto; }
                #keyboard{
                width: 80vw; height: 5vh; padding: 5px 10px; border: 1px solid #555;
                background-color: #333; color: #eee; border-radius: 4px;
                box-sizing: border-box; font-size: 1.1em;
                }
                #icon { cursor: pointer; }

                /* --- Keyboard Container (.ui-keyboard) --- */
                /* Using the class name from keyboard.js css.container option */
                /* .ui-keyboard.ui-widget-content.ui-widget */ /* More specific based on config */
                .ui-keyboard { /* Keep it simple for now */
                position: absolute !important; z-index: 1000; padding: 5px;
                background-color: #111; border: 1px solid #000; border-radius: 4px;
                text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.5);
                font-family: Arial, sans-serif; font-size: 16px; color: #d9d9d9;
                -ms-touch-action: manipulation; touch-action: manipulation;
                }
                /* --- Focus state for keyboard container --- */
                /* .ui-keyboard.keyboard-focused */ /* Using custom class added via JS */
                .ui-keyboard.keyboard-focused {
                    border: 1px solid white;
                }

                /* --- Preview Input --- */
                .ui-keyboard-preview-wrapper { padding: 0 0 5px 0; }
                /* Using the class name from keyboard.js css.input option */
                input.ui-keyboard-preview.ui-widget-content {
                    width: 98%; padding: 5px; margin: 0 auto; box-sizing: border-box;
                    border: 1px solid #444; background-color: #222; color: #eee;
                    border-radius: 3px; text-align: left;
                }

                /* --- Keyset (Rows of keys) --- */
                .ui-keyboard-keyset { text-align: center; white-space: nowrap; font-size: 1em; }

                /* --- Individual Buttons --- */
                /* Base style for all buttons */
                .ui-keyboard-button {
                    height: 2.5em; min-width: 2.5em; margin: 2px; padding: 0 5px;
                    box-sizing: border-box; border-radius: 4px;
                    line-height: 2.5em; text-align: center; vertical-align: middle;
                    cursor: pointer; overflow: hidden; user-select: none;
                    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
                    transition: background-color 0.1s ease-in-out, border-color 0.1s ease-in-out;
                    font-weight: bold; /* Common style */
                    color: #ffffff; /* Common style */
                }

                /* --- Default State Button Style --- */
                /* Using the class name from keyboard.js css.buttonDefault option */
                .ui-keyboard-button.ui-state-default {
                    border: 1px solid #333;
                    background: linear-gradient(to bottom, #404040, #333333); /* Dark grey gradient */
                    /* color: #ffffff; */ /* Moved to base .ui-keyboard-button */
                    /* font-weight: bold; */ /* Moved to base .ui-keyboard-button */
                }

                /* --- Hover State Button Style --- */
                /* Using the class name from keyboard.js css.buttonHover option */
                .ui-keyboard-button.ui-state-hover {
                    border-color: #557799; /* Blueish border */
                    background: linear-gradient(to bottom, #4a6a8a, #3a5a7a); /* Blueish gradient */
                }

                /* --- Active/Action State Button Style --- */
                /* Using the class names from keyboard.js css.buttonActive and css.buttonAction options */
                .ui-keyboard-button.ui-state-active {
                    border-color: #111;
                    background: #222; /* Darker background when pressed/active */
                }

                /* --- Disabled State Button Style --- */
                /* Using the class name from keyboard.js css.buttonDisabled option */
                .ui-keyboard-button.ui-state-disabled {
                    opacity: 0.5;
                    cursor: default;
                    border-color: #555;
                    background: #555;
                }

                /* --- Special Keys --- */
                .ui-keyboard-widekey { min-width: 4em; }
                .ui-keyboard-space { min-width: 15em; }
                .ui-keyboard-actionkey .ui-keyboard-text { /* Style action key text if needed */ }

                /* --- Row Break --- */
                .ui-keyboard-button-endrow { clear: both; display: block; height: 0; margin: 0; padding: 0; }

                /* --- Text inside buttons --- */
                .ui-keyboard-text { display: inline-block; white-space: pre; }

            </style>
            <div id="wrap">
                <input id="keyboard" type="text" class="ui-keyboard-input ui-widget-content ui-corner-all" aria-haspopup="true" role="textbox">
                <!-- img id="icon" src="https://mottie.github.io/Keyboard/docs/css/images/keyboard.png" alt="Keyboard icon" -->
            </div>
                `;
                this.selector = this.shadowRoot.querySelector(`.${this._selector }`);
                //this.bind();
            }

            ishadow() {
                this.init();
                this.shadowRoot.innerHTML = `

            <link rel="stylesheet" type="text/css" href="https://mottie.github.io/Keyboard/css/keyboard.css" >
            <link rel="stylesheet" type="text/css" href="https://code.jquery.com/ui/1.11.4/themes/dot-luv/jquery-ui.css">
            <style>
                #wrap {
                position: fixed;
                top: 50vh;
                left: 50vw;
                width: 0vw;
                height: 0vh;
                z-index: 1;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                padding: 20px;
                box-sizing: border-box;
                gap: 2px;
                }
                #icon{
                position: fixed;
                top: 3%;
                left: 3%;
                transform: scale(1.5);
                
                }
                #keyboard{
                width: 0vw;
                height: 0vh;
                display:none;
                }
                /* --- Keyboard Container (.ui-keyboard) --- */
                .ui-keyboard {
                position: absolute !important; z-index: 1000; padding: 5px;
                background-color: #111; border: 1px solid #000; border-radius: 4px;
                text-align: center; box-shadow: 0 2px 10px rgba(0,0,0,0.5);
                font-family: Arial, sans-serif; font-size: 16px; color: #d9d9d9;
                -ms-touch-action: manipulation; touch-action: manipulation;

                pointer-events: auto;
                backdrop-filter: blur(5px);
                -webkit-backdrop-filter: blur(5px);
                background-color: #1a1a1a;
                border-width: 11px;
                border-style: double;
                border-top-color: #2a2a2a;
                border-left-color: #2a2a2a;
                border-bottom-color: #3a3a3a;
                border-right-color: #3a3a3a;
                border-radius: 100px;
                box-shadow: inset 0 2px 336px rgba(0, 0, 0, 0.7), 0 1px 0px rgba(255, 255, 255, 0.9);

                    background-color: #0a0a10; /* Dark blue/black base */

            
                }
                /* --- Focus state for keyboard container --- */
                .ui-keyboard.keyboard-focused {
                    border: 1px solid white;
                }

                /* --- Preview Input --- */
                input:focus-visible{
                outline :none;
                }
                input.ui-keyboard-preview.ui-widget-content
                {
                    font-family: "Special Elite", system-ui;
                    font-weight: 600;
                    font-style: normal;
                    font-size: 1.4rem;
                    position: relative;
                    width: 75%;
                    height: 73px;
                    padding: 9px;
                    margin: 21px 0px 0px 0px;
                    box-sizing: border-box;
                    border: 5px;
                    border-style: dotted;
                    background-color: #0c0b0bde;
                    color: #000000;
                    border-radius: 0%;
                    text-align: left;
                }
                /* --- Keyset (Rows of keys) --- */
                .ui-keyboard-keyset { 
                margin: 37px 2px 37px 2px;
                padding: 22px;
                text-align: center; white-space: nowrap; font-size: 1em; 
                }

                .ui-keyboard-keyset-normal {
                    border-radius: 55px;
                    box-sizing: border-box;
                    background-color: #434343;
                    margin:  27px;
                    padding: 15px 10px 45px 9px;
                    box-shadow: inset 5px 19px 34px rgb(0 0 0 / 76%), inset -9px -6px 20px rgba(255, 255, 255, 0.8);
                }

                .ui-keyboard-keyset-shift {
                    border-radius: 55px;
                    box-sizing: border-box;
                    background-color: #222222;
                    margin:  27px;
                    padding: 15px 10px 45px 9px;
                    box-shadow: inset 5px 19px 34px rgb(0 0 0 / 76%), inset -9px -6px 20px rgba(255, 255, 255, 0.8);
                }
                /* --- Individual Buttons --- */
                .ui-keyboard-button {
                    margin: 6px;
                    padding: 0 17px;
                    height: 2.5em; min-width: 2.5em; margin: 2px; padding: 0 5px;
                    box-sizing: border-box; border-radius: 4px;
                    line-height: 2.5em; text-align: center; vertical-align: middle;
                    cursor: pointer; overflow: hidden; user-select: none;
                    -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;
                    transition: background-color 0.1s ease-in-out, border-color 0.1s ease-in-out, box-shadow 0.2s ease-out; /* Added box-shadow transition */
                    font-weight: bold; 
                    color: #ffffff;
                    pointer-events: auto;
                    /* Remove default border, use box-shadow for effect */
                    border: none;
                    /* Add base box-shadow for depth */
                    box-shadow: 0 1px 3px rgba(0,0,0,0.5);


                }

                /* --- Default State Button Style --- */
                .ui-keyboard-button.ui-state-default {
                    position: relative;
                    top: 24px;
                    padding: 0 18px;
                    margin: 5px;
                    border-radius: 40%;
                    border-style: outset;
                    border-width: thin;
                    background: linear-gradient(to bottom, #242424, #4f4f4f05);
                }

                /* --- Hover State Button Style --- */
                .ui-keyboard-button.ui-state-hover {
                    background: linear-gradient(to bottom, #3d3f3d, #070807);
                    /* --- Neon Glow Effect (Hover) --- */
                    box-shadow: 0 1px 50px rgb(50 56 56);
                }
                button.ui-keyboard-accept.ui-keyboard-valid-input
                {
                    border-color: #9C27B0;
                    background: #E91E63;
                    color: #fff;
                }

                
                /* --- Active/Action State Button Style --- */
                .ui-keyboard-button.ui-state-active {
                    background: #222;
                    animation: neon-blink 1.5s infinite ease-in-out;
                }


                @keyframes neon-blink {
                    0%, 100% { /* Start and end state (brighter) */
                        box-shadow: 
                        0px 1px 14px 13px rgb(255 0 126 / 34%), 
                        -3px -6px 20px 10px rgb(58 0 255 / 92%);
                    }
                    50% { /* Mid state (dimmer) */
                        box-shadow: 
                        0px 1px 14px 1px rgb(255 0 126 / 34%), 
                        0px 0px 20px 0px rgb(58 0 255 / 92%);
                    }
                }
            

                /* --- Disabled State Button Style --- */
                .ui-keyboard-button.ui-state-disabled {
                    opacity: 0.5; cursor: default;
                    background: #555;
                    box-shadow: 0 1px 2px rgba(0,0,0,0.4); /* Simpler shadow for disabled */
                }

                /* --- Special Keys --- */
                .ui-keyboard-widekey { min-width: 4em; }
                .ui-keyboard-space { min-width: 15em; }
                .ui-keyboard-actionkey .ui-keyboard-text { /* Style action key text if needed */ }

                /* --- Row Break --- */
                .ui-keyboard-button-endrow { clear: both; display: block; height: 0; margin: 0; padding: 0; }

                /* --- Text inside buttons --- */
                .ui-keyboard-text { 
                    display: inline-block; 
                    white-space: pre; 
                    pointer-events: none;
                    font-family: "Special Elite", system-ui;
                    font-weight: 600;
                    font-style: normal;
                    font-size: 1.4rem;
                    color: black;
                }
                /* --- Help Modal Styles --- */
                #help-modal {
                    position: fixed;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    width: 100%;
                    height: 75%;
                    max-width: 100vw;
                    background-color: rgb(0 0 0 / 42%);
                    color: #3f3f3f;
                    border: 1px solid #555;
                    border-radius: 5px;
                    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.7);
                    padding: 30px;
                    z-index: 2000;
                    backdrop-filter: blur(6px);
                    -webkit-backdrop-filter: blur(3px);
                    font-family: "Dela Gothic One", sans-serif;
                    font-weight: 400;
                    font-style: normal;
                    display: none;
                    opacity: 0;
                    transition: opacity 1.3s ease-in-out;
                }
                #help-modal.visible {
                    display: block;
                    opacity: 1;
                }
                .modal-content h2 {
                    margin-top: 0;
                    color: #e91e63;
                    text-align: center;
                    border-bottom: 6px solid #cb1ee966;
                    padding-bottom: 25px;
                    margin-bottom: 45px;
                    font-size: 2.4rem;
                    font-weight: 100;
                }
                .modal-content p {
                    line-height: 1.6;
                    text-align: center;
                    color: #9b0077;
                    font-size: 1.2rem;
                }
                .modal-content ul {
                    list-style: decimal;
                    margin-left: 10%;
                    color: #9b00ff;
                    font-size: 1.6rem;
                }
                .close-button {
                    position: absolute;
                    top: 10px;
                    right: 15px;
                    background: none;
                    border: none;
                    color: #aaa;
                    font-size: 24px;
                    font-weight: bold;
                    cursor: pointer;
                    padding: 0;
                    line-height: 1;
                }
                .close-button:hover {
                    color: #fff;
                }
            </style>

            <div id="wrap">
                <input id="keyboard" type="text" class="ui-keyboard-input ui-widget-content ui-corner-all" aria-haspopup="true" role="textbox">
                <img id="icon" src="https://mottie.github.io/Keyboard/docs/css/images/keyboard.png">
            </div>

            
                `;
                this.selector = this.shadowRoot.querySelector(`.${this._selector }`);
                //this.bind();
            }
            connectedCallback() {
                // --- Load the keyboard initialization script ---
                const scriptElem = document.createElement('script');
                scriptElem.type = 'module';
                scriptElem.src = '/components/script/keyboard.js'; // This script should initialize $('#keyboard').keyboard({...})

                // --- Add contextmenu listener AFTER the script is likely loaded and keyboard initialized ---
                // For robustness, ideally keyboard.js should signal when it's done,
                // but we'll attach the listener after appending the script for now.
                scriptElem.onload = () => {
                    this.addContextMenuListener();
                    console.log("keyboard.js loaded and context menu listener added.");
                };
                scriptElem.onerror = () => {
                    console.error("Failed to load keyboard.js");
                };

                this.shadowRoot.appendChild(scriptElem);

                // Fallback in case onload doesn't fire reliably in all scenarios or keyboard.js is very fast
                // setTimeout(() => this.addContextMenuListener(), 500); // Less ideal, but a potential fallback
            }

            disconnectedCallback() {
                // Remove context menu listener
                if (this.boundContextMenuListener) {
                window.removeEventListener('contextmenu', this.boundContextMenuListener);
                console.log("Context menu listener removed from document.");
                this.boundContextMenuListener = null;
                }
                // Clean up modal if it exists
                const existingModal = this.shadowRoot.querySelector('#help-modal');
                if (existingModal) {
                    existingModal.remove();
                }
            }
                
            addContextMenuListener() {
                const keyboardInput = this.shadowRoot.querySelector('#keyboard');

                if (keyboardInput) {
                    this.boundContextMenuListener = this.handleContextMenu.bind(this, keyboardInput);
                    document.addEventListener('contextmenu', this.boundContextMenuListener);
                } else {
                    console.error("#keyboard element not found in shadow DOM for context menu listener setup.");
                }
            }
                
            handleContextMenu(keyboardInput, event) {
                event.preventDefault(); // Prevent the default browser context menu
                console.log("Right-click detected on #wrap");

                try {
                    const kbInstance = $(keyboardInput).getkeyboard(); // Get the keyboard instance
                    if (kbInstance && typeof kbInstance.reveal === 'function') {
                    // Check if keyboard is already visible to potentially toggle or just reveal
                    if (!kbInstance.isOpen) {
                        console.log("Revealing keyboard...");
                        kbInstance.reveal(); // Show the keyboard
                    } else {
                        console.log("Keyboard already open.");
                        // Optionally, close it on second right-click: kbInstance.close();
                    }
                    } else {
                        console.error("Could not get keyboard instance or reveal method.");
                    }
                } catch (err) {
                    console.error("Error accessing keyboard instance:", err);
                }

            
            }
            // --- Method to handle the 'accepted' event ---
            handleKeyboardAccept(finalValue) {
                console.log(`Keyboard accepted value: "${finalValue}"`);
            　　　this.externalCB(finalValue);
                // --- Add your switching logic here based on the finalValue ---
                switch (finalValue.toLowerCase()) {
                    case 'animate1':
                        console.log('Triggering Animation 1...');
                        // Call your animation function: triggerAnimation('animationType1');
                        break;
                    case 'mode_toggle':
                        console.log('Toggling mode...');
                        // Call your mode toggle function: toggleApplicationMode();
                        break;
                    case 'reset':
                        console.log('Resetting...');
                        // Call your reset function: resetScene();
                        break;
                    case 'help': // Added help case
                        console.log('Showing help modal...');
                        this.showHelpModal(); // Call the new method
                        break;
                    default:
                        console.log('No specific action defined for this value.');
                        // Handle default case or do nothing
                }

                // Optionally clear the input after processing, EXCEPT for help
                if (finalValue.toLowerCase() !== 'help') {
                    const keyboardInput = this.shadowRoot.querySelector('#keyboard');
                    if (keyboardInput) {
                        $(keyboardInput).val(''); // Clear jQuery val
                        const kbInstance = $(keyboardInput).getkeyboard();
                        if (kbInstance && kbInstance.$preview) {
                            kbInstance.setValue(''); // Use plugin's method if possible
                        }
                    }
                }
            }
            // --- End handleKeyboardAccept ---

            // --- Method to show the help modal ---
            showHelpModal() {
                // Remove existing modal first to prevent duplicates
                const existingModal = this.shadowRoot.querySelector('#help-modal');
                if (existingModal) {
                    existingModal.remove();
                }

                // Create modal elements
                const modal = document.createElement('div');
                modal.id = 'help-modal';

                const modalContent = document.createElement('div');
                modalContent.classList.add('modal-content');

                const closeButton = document.createElement('button');
                closeButton.classList.add('close-button');
                closeButton.innerHTML = '&times;'; // 'x' symbol
                closeButton.onclick = () => {
                    modal.classList.remove('visible');
                    // Remove after transition ends
                    setTimeout(() => modal.remove(), 300);
                };

                const title = document.createElement('h2');
                title.textContent = 'ヘルプ情報';

                const helpText = document.createElement('p');
                helpText.textContent = 'ここにキーボードの操作方法や、入力可能なコマンドの説明などを記述します。';

                const commandList = document.createElement('ul');
                const commands = ['animate1: アニメーション1を開始', 'mode_toggle: モード切り替え', 'reset: リセット', 'help: このヘルプを表示'];
                commands.forEach(cmdText => {
                    const li = document.createElement('li');
                    li.textContent = cmdText;
                    commandList.appendChild(li);
                });

                // Assemble modal
                modalContent.appendChild(closeButton);
                modalContent.appendChild(title);
                modalContent.appendChild(helpText);
                modalContent.appendChild(commandList);
                modal.appendChild(modalContent);

                // Append to shadow DOM
                this.shadowRoot.appendChild(modal);

                // Trigger fade-in effect
                requestAnimationFrame(() => {
                    modal.classList.add('visible');
                });
            }
            // --- End showHelpModal ---
            static instanciate(parent){
                let selector =  document.createElement('virtual-keyboard-component');
                parent.appendChild(selector);
            }
        }

        customElements.define('virtual-keyboard-component', VirtualKeyboardComponent);



        import { rotationParams } from '/components/hedron/platonic-data.js'; // 軸/角度データをインポート
        import { generateMatrixFromAxisAngle } from '/components/hedron/matrix-utils.js'; // 行列生成関数をインポート
        import { MatrixPathNavigator } from '/components/hedron/MatrixPathNavigator.js'; // 新しいクラスをインポート

        import * as glMatrix  from 'https://cdn.jsdelivr.net/npm/gl-matrix@3.4.3/+esm'
// Requires gl-matrix library (loaded via CDN in html)

        const mat4 = glMatrix.mat4; // 4x4 matrix functions

        // --- データ準備: 軸/角度データから行列データを作成 ---
        function createOperationMatrixMap(params) {
            const matrixMap = new Map();
            for (const opId in params) {
                const param = params[opId];
                const matrix = generateMatrixFromAxisAngle(param.axis, param.angle);
                matrixMap.set(opId, matrix);
            }
            return matrixMap;
        }

        // PolyhedronComponent
        const getNagivator = (selectedGroup = 'T')=>{

            let userPath = [];

            const operationMatrices = {
                T: createOperationMatrixMap(rotationParams.T),
                O: createOperationMatrixMap(rotationParams.O),
                I: createOperationMatrixMap(rotationParams.I)
            };

            if (selectedGroup === 'T') {
                    userPath = ['T_C3_111_120', 'T_C2_X_180', 'T_C3_111_240', 'T_C2_X_180'];
            } else if (selectedGroup === 'O') {
                // 例: Oグループのパス (軸周りの90度回転など)
                    userPath = ['O_C4_Z_90', 'O_C4_X_90', 'O_C3_111_120', 'O_C4_X_270', 'O_C4_Z_270'];
            } else { // Iグループ (データ不完全なので注意)
                    userPath = ['I_C5_A1_72', 'I_C2_C1_180', 'I_C5_A1_144']; // 例
            }

            console.log(`Setting up navigator for Group: ${selectedGroup}, Path:`, userPath);

            // ナビゲーターを初期化
            return new MatrixPathNavigator(operationMatrices[selectedGroup], userPath);
        };


        class PolyhedronComponent extends BaseHTMLComponentWithEvent {
    #shadowRoot;
    #config = null;
    #elements = new Map(); // Store references to created elements
    #rotatedState = new Map(); // Store rotated state for each element id
    #hinge_done = new Map();
    #data_num = 0;
    // --- Dragging State ---
    #isDragging = false;
    #startX = 0;
    #startY = 0;
    // Store scene position instead of rotation
    #initialSceneTop = 0;
    #initialSceneLeft = 0;
    #currentSceneTop = 0;
    #currentSceneLeft = 0;
    #sceneElement = null; // Reference to the scene element
    #rboxContainer = null; // Reference to the container (still needed for content)

    // --- Bound Event Listeners ---
    // Use bound functions to ensure 'this' context and allow easy removal
    #boundHandleDragStart = this.#handleDragStart.bind(this);
    #boundHandleDragMove = this.#handleDragMove.bind(this);
    #boundHandleDragEnd = this.#handleDragEnd.bind(this);

    
    #faceTree = null;
    #center  = null;
    #currentNode = null;
    #navigator = null;
    #orbit =null;
    constructor() {
        super();
    }
    ishadow(){}
    set data_num(num) {
        this.#data_num = num;
    }
    // Configuration data can be set via property
    set config(newConfig) {
        if (!this.#isValidConfig(newConfig)) {
            console.error('Invalid configuration provided to polyhedron-rotator.');
            return;
        }
        this.#config    = newConfig;
        var Char = '';
        switch (this.#data_num) {
            case 0:
                Char =  'T';
                break;
            case 1:
            case 2:
                Char = 'O';
                break;
            case 3:
            case 4:
                Char = 'I';
                break;
            default:
                Char = 'O';
                break;   
        }
        this.#navigator = getNagivator(Char);
        
        this.#rotatedState.clear(); // Reset state when config changes
        this.#calcCenter();
        this.#render();
        this.foldAll();
    }
    #calcCenter(){
        const { width, height, perspective, transitionDuration,margin } = this.#config.settings;
        this.width  = parseInt(width.replace("px","")); // Default width
        this.height = parseInt(height.replace("px","")); // Default width
        this.margin = margin || '0%'; // Default margin
        const solid = this.#config.solid;
        const net = this.#config.net;
        var amount1 = solid[0][0]*solid[0][1];
        var amount2 = net[0][0]*net[0][1];
        if(amount1 != amount2){
            console.error(`not equal solid${amount1} <=> net ${amount2}`);
        }
        const  amount = parseInt(this.#config.vertices.length/2)
        const verts = this.#config.vertices;

        
        var fcenter = [0.,0.,0.];
        var center =[ 0.,0,0.];
        var s  =  new Set();
        const getV = (v1,v2) =>{
            return [ v1[0] -v2[0],v1[1] -v2[1],v1[2] -v2[2]];
        };
        const  vN = solid[1][0];
        var    axis = [];
        solid.slice(1).forEach((i,n) => {
            i.slice(1).forEach( (_vi,n2)=>{
                var vi = _vi +1;
                if(n==0){
                    axis.push(getV(verts[vi],verts[ i[ ((n2-1+vN) % vN) + 1 ]]));
                    [0,1,2].forEach((j)=>fcenter[j] += verts[vi][j]);
                }
                if(!s.has(vi)){
                    console.log(` ${vi}  ${verts[vi]}`);
                    [0,1,2].forEach( (j) => {
                        center[j] += verts[vi][j];
                        console.log(` ${vi}  ${j}  ${center[j]}`);
                    });
                    s.add(vi);
                }
            });
        });

        var origin = [ 0.0,0.0,0.0];
        const v0 = this.#config.vertices[solid[1][1]+1];
        var  L  = 0.0;
        var  OL  = 0.0;
        [0,1,2].forEach((i)=> {
            
            center[i] = center[i]/s.size;
            fcenter[i] = fcenter[i]/solid[1][0];
            origin[i] = (fcenter[i] - center[i]);
            var oL = origin[i]*origin[i];
            OL += oL;
            var l = v0[i] - fcenter[i];
            L += l*l;
        });
        
        L  = Math.sqrt(L);
        OL = Math.sqrt(OL);
        this.scale   = this.width/L/2.;
        
        
        this.angle   =    Math.PI - this.#config.hinges[1][4];
        this.axis    =    axis;
        this.torigin =    OL*this.scale;
        console.log(`origin ${origin} ${OL} `);
        console.log( `rotate3d(${this.axis[0][0]}, ${this.axis[0][1]}, ${this.axis[0][2]},${this.angle}rad)` );
        console.log( `rotate3d(${this.axis[1][0]}, ${this.axis[1][1]}, ${this.axis[1][2]},${this.angle}rad)` );
        console.log( `rotate3d(${this.axis[2][0]}, ${this.axis[2][1]}, ${this.axis[2][2]},${this.angle}rad)` );
    }
    get config() {
        return this.#config;
    }

    async GetPolyhedron() {
      async function fetchData(data_num) {
          try {
              const response = await fetch(`/hedron/data/${data_num}.json`);
              const data = await response.json();
              const jsonData = {
                  "settings": {
                          width: '1000px',
                          height: '1000px',
                          perspective: '80000px', // Perspectiveを調整
                          transitionDuration: '0.1s',
                          margin:"0%"
                      },
                  "net" :data.net,
                  "hinges":data.hinges,
                  "vertices":data.vertices,
                  "solid" :data.solid,
                  "svertices" :data.svertices
              }
              
              return jsonData;
              console.log('GET Response:', data);
          } catch (error) {
              console.error('Error with GET request:', error);
          }
      }
      return  fetchData(this.#data_num);
  };
  
    #isValidConfig(config) {
        return config && config.settings && config.net && config.hinges && config.vertices;
    }

    connectedCallback() {
        this.#shadowRoot = this.shadowRoot;
        // Optionally set a default config if none is provided
        /*
        if (!this.#config) {
            console.warn("Polyhedron configuration not set. Using default.");
            this.config = cubeLikeConfig; // Set default here
        }
            */
    }
    
    disconnectedCallback() {
        // Clean up global event listeners when component is removed
        document.removeEventListener('mousemove', this.#boundHandleDragMove);
        document.removeEventListener('mouseup', this.#boundHandleDragEnd);
        document.removeEventListener('touchmove', this.#boundHandleDragMove);
        document.removeEventListener('touchend', this.#boundHandleDragEnd);
     }
    
    #render() {
        if (!this.#config) return;

        this.#shadowRoot = this.shadowRoot;
        const { width, height, perspective, transitionDuration,margin } = this.#config.settings;
        this.width  = parseInt(width.replace("px","")); // Default width
        this.height = parseInt(height.replace("px","")); // Default width
        this.margin = margin || '0%'; // Default margin
        // --- Create Styles ---

        // --- Create Structure ---
        this.#shadowRoot.innerHTML = ''; // Clear previous content
        this.#elements.clear();
        this.#hinge_done.clear();
        this.#faceTree = null;
        
        const scene = document.createElement('div');
        scene.className = 'scene';
        // Set initial position (e.g., center)
        // Get initial computed position if possible, otherwise use default
        // Note: Getting computed style before appending might not work reliably
        this.#currentSceneTop = 25; // Default to 50%
        this.#currentSceneLeft = 50; // Default to 50%
        scene.style.top = `${this.#currentSceneTop}%`;
        scene.style.left = `${this.#currentSceneLeft}%`;
        scene.style.transform = 'translate(0%, 0%)'; // Keep centering transform

        // Build the element tree recursively

        const rootContainer = document.createElement('div');
        rootContainer.className = 'rbox-container'; // Container for positioning
        scene.appendChild(rootContainer);

        const axisContainer = document.createElement('div');
        axisContainer.className = 'rbox-container'; // Container for positioning
        axisContainer.id        = "axis";
        scene.appendChild(axisContainer);
        
        this.axisContainer  = axisContainer;
        this.#rboxContainer = rootContainer; // Store reference
        // Apply a fixed rotation if desired, or keep it dynamic
        this.#rboxContainer.style.transform = `rotateX(0deg) rotateY(0deg)`;
        this.#buildElementRecursive(0,this.#config.hinges[1],{x:0.,y:0.},null);
        this.#currentNode =  this.#faceTree;
        const style = document.createElement('style');
        style.textContent = `
            :host { /* Style the component host itself */
                display: inline-block; /* Allow component to size itself */
                --w: ${width};
                --h: ${height};
                --m:${margin};
                --transition-duration: ${transitionDuration || '0.8s'};
                --grid-color: rgba(0, 255, 255, 0.7); /* Cyan grid color */
                --grid-size: 5%; /* Size of the grid cells */
                --line-thickness: 1px; /* Thickness of grid lines */
                background-color: #00ffff00;
                position:fixed;
                z-index:1;
            }
            .scene {
                position:fixed;
                top:25%;
                left:25%;
                width: calc(var(--w) * 3); /* Adjust scene size based on element size */
                height: calc(var(--h) * 3);
                transform: scale(1.0);
                perspective: ${perspective || '800px'};
                /* Add cursor style to indicate draggability */
                cursor: grab;
                /* Add transition for smooth movement end */
                transition: top 0.1s ease-out, left 0.1s ease-out;
                z-index:1000;
            }
            .scene.dragging { /* Style when dragging */
                cursor: grabbing;
                transition: none !important; /* Disable transition during drag */
            }
            
            .rbox-container { /* Container for the root element */
                 position: relative; /* Needed for absolute children */
                 transform-style: preserve-3d;
                 transition: transform 0.1s ease-out; /* Short transition for settling */
                 //pointer-events: none;
                 width: var(--w);
                 height: var(--h);
                 background-color:#faebd700;
            }
            
            .rbox-container.no-transition {
                 transition: none !important; /* Disable transition during drag */
            }

            
            .rbox-element {
                position: absolute;

                width: var(--w);
                height: var(--h);
                transform-style: preserve-3d;
                transition: transform var(--transition-duration) ease-in-out;
                /* transform-origin and transform set by JS */
                background-color: #00ffff00;
            }
            
            .box-content {
                position: absolute;
                width: 100%;
                height: 100%;
              
                background-image:
                /* Horizontal lines */
                repeating-linear-gradient(
                    to bottom,
                    transparent,
                    transparent calc(var(--grid-size) - var(--line-thickness)),
                    var(--grid-color) var(--grid-size)
                ),
                /* Vertical lines */
                repeating-linear-gradient(
                    to right,
                    transparent,
                    transparent calc(var(--grid-size) - var(--line-thickness)),
                    var(--grid-color) var(--grid-size)
                );

                border-radius: 0px;
                border: calc( var(--w) / 4 ) double rgb(65 76 51);
                color: #000000;
                box-sizing: border-box;
                margin: var(--m);
                padding: 0px;
                font-weight: bold;
                cursor: pointer;
                user-select: none;
               
                font-family: 'Special Elite';
                font-size: xx-large;
                place-items: center;
                display: grid;
            }


            .box-content::before {
                content: '';
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color:#c0f8ff99;
                box-shadow: 0 0 30vw rgb(159 160 160 / 56%), 0 0 6px rgb(104 117 25 / 88%), 0 0 174px rgb(255 77 0 / 70%), 0 0 18px rgba(89, 0, 255, 0.7), 0 0 24px rgb(128 221 70 / 80%), 0 0 30px rgba(0, 229, 255, 0.6), 0 0 45px rgba(255, 247, 0, 0.8);
                border-radius: 36px;
                z-index: -1;
            }

            .axis{
                transform: rotateX(-49.5deg) rotateY(5deg);
                background-color: #6efa0054;
                background-clip: content-box;
                box-sizing: border-box;
            }
            .axis2 {
                position: absolute;
                width: 100%;
                height: 100%;
              
                background-color: #6e0a7754;
                color: #000000;
                box-sizing: border-box;

                padding: 0px;
                font-weight: bold;

                font-family: 'Special Elite';
                font-size: xx-large;

            }

            
    `;

        this.#shadowRoot.appendChild(style);
        this.#shadowRoot.appendChild(scene);
        // Add listener to the container, not the scene, for better control
        
        //scene.addEventListener('mousedown', this.#boundHandleDragStart);
        //scene.addEventListener('touchstart', this.#boundHandleDragStart, { passive: false }); // Use passive: false if preventDefault is needed
        
        this.#sceneElement　=scene;
        // Apply initial transforms after elements are in the DOM
        //this.#updateAllTransforms();
    }
    
    #toViewport(vx,vy){
        return {
            x: (vx * this.scale),
            y: (vy * this.scale)
        }; 
    }

    #buildElementRecursive(i,hinge,parentPos,parentNode) {
        const data_id = `face-${i}`;
        var centroid  = null; 
        let currentNode = null; 
        if(!this.#elements.get(data_id)){
            
            const verts    = this.#config.net[i+1].slice(1);
            centroid = this.#calculateCentroid(verts);
            const maxDist  = this.#calculateMaxDistance(verts, centroid);

            const elementWrapper = document.createElement('div');
            elementWrapper.className = 'rbox-element';
            elementWrapper.dataset.id = `face-${i}`; // Store id for later reference
            
            const boxContent = document.createElement('div');
            boxContent.className = 'box-content';
            boxContent.textContent = `${i}asdfojasdjfpsjdofpfjoj ojspojfdfopjwoedfjwojfvopj vdojkvosjdfpojssdojvopj pojpofjedopfjposajfdpojweopf` ;//elementConfig.content || '';
            elementWrapper.appendChild(boxContent);
           
            const pathData = this.#getCentroidRelativePercentages(verts, centroid,maxDist);
            boxContent.style.clipPath = `polygon(${pathData
            .map(p => `${p[0].toFixed(2)}% ${p[1].toFixed(2)}%`)
            .join(', ')})`;
            if(i == 0){
                elementWrapper.style.transform = elementWrapper.transformTranslate = `translate3d(0px ,0px, ${this.torigin}px)`;
            }else{
                const dst = this.#toViewport(centroid.x - parentPos.x,centroid.y - parentPos.y);
                elementWrapper.style.transform = elementWrapper.transformTranslate = `translate3d(${Math.round(dst.x)}px,${Math.round(dst.y)}px,0px) `;                
            }
            currentNode = {
                        parent : parentNode,
                        id: data_id,
                        element: elementWrapper, // Reference to the DOM element
                        chid :-1,
                        children: []
            };
            if (parentNode) {
                parentNode.element.appendChild(elementWrapper);
                parentNode.children.push(currentNode);
            } else {
                // This is the root node (face 0)
                this.#rboxContainer.appendChild(elementWrapper);
                this.#faceTree = currentNode;
                
            }
            // Store reference and initial state
            this.#elements.set(elementWrapper.dataset.id, elementWrapper);
            this.#rotatedState.set(elementWrapper.dataset.id, false); // Initially not rotated
            
            /*
            boxContent.addEventListener('click', (e) => {
                e.stopPropagation(); // Prevent event bubbling to parent elements
                this.#toggleRotation(elementWrapper.dataset.id);
            });
            */

            if(i!=0 ){
                const vertices = this.#config.vertices;
                const fid  = parseInt(hinge[2]) + 1;
                const n    = this.#config.net[fid][0];
                const vid  = parseInt(hinge[3]) + 1;
                const v1   = vertices[ (this.#config.net[fid][vid]) + 1 ];
                const v2   = vertices[ parseInt(this.#config.net[fid][(vid==n)?1:vid+1]) + 1 ];
                const mid  = this.#calculateMidpoint(v1,v2);
                const midper = this.#convertToCentroidPercentage(mid, centroid, maxDist);
                elementWrapper.style.transformOrigin = `${midper[0]}% ${midper[1]}%`;
                elementWrapper.transformRotate       = `rotate3d(${v1[0] - mid[0]}, ${v1[1] - mid[1]},0, ${180- (hinge[4] * 180 / Math.PI)}deg)`;
                elementWrapper.transformRotate2      = `rotate3d(${v1[0] - mid[0]}, ${v1[1] - mid[1]},0, -${180- (hinge[4] * 180 / Math.PI)}deg)`;
            }
        }
        const elementWrapper = this.#elements.get(data_id);
      
        this.#config.hinges.slice(1).forEach((hinge, hingeIndex) => {
            if(this.#hinge_done.get(hingeIndex)){
                return;
            }
            if(i == hinge[0]){
                this.#hinge_done.set(hingeIndex,true);
                this.#buildElementRecursive(hinge[2],hinge,centroid,currentNode);
            }
            if(this.#hinge_done.get(hingeIndex)){
                return;
            }
            if(i == hinge[2]){
                this.#hinge_done.set(hingeIndex,true);
                this.#buildElementRecursive(hinge[0],[hinge[2],hinge[3],hinge[0],hinge[1],hinge[4]],centroid,currentNode);
            }
        });
    }

    #toggleRotation(elementId) {
        const currentState = this.#rotatedState.get(elementId);
        this.#rotatedState.set(elementId, !currentState);
        this.#updateTransform(elementId);
    }

    #updateTransform(elementId) {
         const elementWrapper = this.#elements.get(elementId);
         //const elementConfig = this.#config.elements.find(el => el.id === elementId);
         if (!elementWrapper) return;

         const isRotated = this.#rotatedState.get(elementId);
         let transformString = '';

         // 1. Apply initial offset (relative to parent)
         if (elementWrapper.transformTranslate) {
             transformString += elementWrapper.transformTranslate;
         }
         // 2. Apply rotation if in rotated state
         if (isRotated && elementWrapper.transformRotate) {
            transformString += elementWrapper.transformRotate;
         } 

         
         elementWrapper.style.transform = transformString.trim();
        }

    foldAll() {
        this.#elements.forEach((element, elementId) => {
            if (this.#rotatedState.get(elementId) === false) {
                this.#rotatedState.set(elementId, true);
                this.#updateTransform(elementId);
            }
        });
    }

    unfoldAll() {
        this.#elements.forEach((element, elementId) => {
             if (this.#rotatedState.get(elementId) === true) {
                this.#rotatedState.set(elementId, false);
                this.#updateTransform(elementId);
            }
        });
    }
    
    nextFace(){
        if (!this.#navigator) return;
        const result = this.#navigator.stepForward(); // "turn"
        if (result.success) {
            // console.log(`進む: ${result.operationId} 適用 => ${navigator.currentTransformCSS}`);
            this.#navigator.applyToElement(this.#rboxContainer);

        }
    };
    backFace(){
        if (!this.#navigator) return;
        const result = this.#navigator.stepBackward(); // "return"
        if (result.success) {
            // console.log(`戻る: ${result.undoneOperationId} 解除 => ${navigator.currentTransformCSS}`);
            this.#navigator.applyToElement(this.#rboxContainer);
        }
       
    }
    // --- Drag Handlers ---
    #handleDragStart(event) {
        // Prevent default only for touch to avoid issues like text selection on desktop
        if (event.type === 'touchstart') {
            event.preventDefault();
        }

        // Ignore if clicking on a face (box-content)
        if (event.target.classList.contains('box-content')) {
            return;
        }

        this.#isDragging = true;
        // Use pageX/pageY for mouse, clientX/clientY for touch
        const touch = event.touches ? event.touches[0] : null;
        this.#startX = touch ? touch.clientX : event.pageX;
        this.#startY = touch ? touch.clientY : event.pageY;
        // Store initial rotation when drag starts
        // Store initial scene position (parse from style, fallback needed if not set)
        const style = window.getComputedStyle(this.#sceneElement);
        // Get position relative to viewport, considering potential transform: translate(-50%, -50%)
        const rect = this.#sceneElement.getBoundingClientRect();
        this.#initialSceneLeft = rect.left ; // Center X
        this.#initialSceneTop = rect.top ; // Center Y

        // Add dragging class to scene
        if (this.#sceneElement) {
            this.#sceneElement.classList.add('dragging');
        }

        // Add move/end listeners to the document
        document.addEventListener('mousemove', this.#boundHandleDragMove);
        document.addEventListener('mouseup', this.#boundHandleDragEnd);
        document.addEventListener('touchmove', this.#boundHandleDragMove, { passive: false });
        document.addEventListener('touchend', this.#boundHandleDragEnd);

        console.log("Scene Drag Start - Initial Top:", this.#initialSceneTop, "Initial Left:", this.#initialSceneLeft);
    }

    #handleDragMove(event) {
        if (!this.#isDragging || !this.#rboxContainer) return;

        // Prevent scrolling during touch drag
        if (event.type === 'touchmove') {
           // event.preventDefault(); // Only prevent if needed
        }

        const touch = event.touches ? event.touches[0] : null;
        const currentX = touch ? touch.clientX : event.pageX;
        const currentY = touch ? touch.clientY : event.pageY;

        const deltaX = currentX - this.#startX;
        const deltaY = currentY - this.#startY;

        // Calculate new scene position (center point)
        this.#currentSceneLeft = this.#initialSceneLeft + deltaX;
        this.#currentSceneTop = this.#initialSceneTop + deltaY;

        // Apply the position transformation (using top/left in pixels)
        // The translate(-50%, -50%) remains to keep it centered on the coordinates
        this.#sceneElement.style.left = `${this.#currentSceneLeft}px`;
        this.#sceneElement.style.top = `${this.#currentSceneTop}px`;

        // console.log(`Dragging Scene: dX=${deltaX}, dY=${deltaY}, Top=${this.#currentSceneTop}px, Left=${this.#currentSceneLeft}px`);
    }

    #handleDragEnd(event) {
        if (!this.#isDragging) return;

        this.#isDragging = false;

        // Remove dragging class from scene
         if (this.#sceneElement) {
            this.#sceneElement.classList.remove('dragging');
        }

        // Remove global listeners
        document.removeEventListener('mousemove', this.#boundHandleDragMove);
        document.removeEventListener('mouseup', this.#boundHandleDragEnd);
        document.removeEventListener('touchmove', this.#boundHandleDragMove);
        document.removeEventListener('touchend', this.#boundHandleDragEnd);

        console.log("Scene Drag End");
    }
    // --- End Drag Handlers ---


        /** ポリゴンの重心を計算 */
    #calculateCentroid(vertices) {
        let sumX = 0, sumY = 0;
        const verts = this.#config.vertices;
        vertices.forEach(vid => { 
            const v = verts[vid+1];
            sumX += v[0]; sumY += v[1]; 
        });
        const n = vertices.length;
        return { x: n > 0 ? sumX / n : 0, y: n > 0 ? sumY / n : 0 };
    }

    /** 2点間の距離を計算 */
    #calculateDistance(point1, point2) {
        const verts = this.#config.vertices;
        
        const dx = verts[point1+1][0] - point2.x;
        const dy = verts[point1+1][1] - point2.y;
        return Math.sqrt(dx * dx + dy * dy);
    }

    /** 重心から最も遠い頂点までの距離を計算 */
    #calculateMaxDistance(vertices, centroid) {
        let maxDist = 0;
        vertices.forEach(vertex => {
            const dist = this.#calculateDistance(vertex, centroid);
            if (dist > maxDist) maxDist = dist;
        });
        return maxDist;
    }

    /** 絶対座標を重心基準のパーセンテージ座標に変換 */
    #convertToCentroidPercentage(v, centroid, maxDist) {
        
        const percentX = maxDist === 0 ? 50 : 50 + ((v[0] - centroid.x) / maxDist) * 50;
        const percentY = maxDist === 0 ? 50 : 50 + ((v[1] - centroid.y) / maxDist) * 50;
        return[percentX, percentY ];
    }

    /** 重心基準のパーセンテージ座標の配列を計算 */
    #getCentroidRelativePercentages(vertices, centroid, maxDist) {
        if (!vertices || vertices.length === 0) return [];
        return vertices.map(vid =>{
            const v = this.#config.vertices[vid+1];
            return this.#convertToCentroidPercentage(v, centroid, maxDist);
        });
    }

    #createOrbit(){
      if(this.#orbit == null){
          this.#orbit = new Orbit(this.axisContainer,[this.#rboxContainer]);
      }else{
          //delete this.#oribit;
          this.#orbit = null;
      }
    }
    /**
     * 2点の中点を計算する
     * @param {{x: number, y: number}} point1
     * @param {{x: number, y: number}} point2
     * @returns {{x: number, y: number}} 中点の座標
     */
    
    keymap(){
              // --- Switching logic ---
        const self  = this;
        return (finalValue) => {
              var f = finalValue.split(" ");
              switch (f[0].toLowerCase()) {
                  case 'load':
                      this.data_num = parseInt(f[1]);
                      this.GetPolyhedron().then(data => {
                        this.config = data;
                      });
                      break;
                  case 'fold':
                      console.log('Folding polyhedron...');
                      if (typeof self.foldAll === 'function') {
                          self.foldAll();
                      } else {
                          console.error('polyhedronComp.foldAll is not a function');
                      }
                      break;
                  case 'unfold':
                      console.log('Unfolding polyhedron...');
                       if (typeof self.unfoldAll === 'function') {
                          self.unfoldAll();
                      } else {
                           console.error('polyhedronComp.unfoldAll is not a function');
                      }
                      break;
                  case 'next':
                      self.nextFace();
                      break;
                  case 'back':
                      self.backFace();
                      break;
                  case 'orbit':
                      this.#createOrbit();
                      break;
                  default:
                      console.log('No specific action defined for this value.');
              }
         };
    }

    #calculateMidpoint(p1, p2,scale = [1.0,1.0]) {
        return [ (p1[0] + p2[0]) / 2 *scale[0] , (p1[1] + p2[1]) / 2* scale[1]];
    }


}

        customElements.define('polyhedron-component', PolyhedronComponent);

        // Example usage
        let polyhedronElement = createElement('polyhedron-component');
        polyhedronElement.data_num = 0;
        polyhedronElement.GetPolyhedron().then(data => {
            polyhedronElement.config = data;
        });
        document.body.appendChild(polyhedronElement);
        let kb = createElement('virtual-keyboard-component');
        kb.externalCB = polyhedronElement.keymap();
        document.body.appendChild(kb);
    </script>
    

</body>
</html>